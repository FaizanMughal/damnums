/*
 * DamNums: by Xaser Acheron
 */

enum DamNum_Fonts
{
	DAM_FONT_CLASSIC = 0,
	DAM_FONT_SMALL   = 1,
	DAM_FONT_MODERN  = 2,
};

class DamNum : Actor
{
	string fontPrefix;
	int digitCount;
	int digitPlace;
	uint8 digitValue;
	name damageType;
	
	const FADE_AMT = 0.05;
	const DAMAGE_CAP = 99999;
	
	Default
	{
		RenderStyle 'Add';
		Alpha 1.0;
		Gravity 0.4;
		Scale 0.75;

		-SOLID;
		+NOBLOCKMAP;
		+NOBLOCKMONST;
		+THRUACTORS;
	}
	States
	{
	Spawn:
		#### # 10 Bright;
		#### # 1 Bright A_FadeOut(FADE_AMT, 1);
		Wait;
	}
	
	/*
	 * DamNum setup function. Sets the correct sprite based
	 * on the digit and the place/number-length. This is necessary
	 * to offset it correctly relative to the viewer.
	 */
	override void PostBeginPlay()
	{
		// Figure out what digit we are.
		DamNum this = DamNum(self);
		int digitCount = (this.digitCount == 0) ? 1 : this.digitCount;
		int digitPlace = (this.digitPlace == 0) ? 1 : this.digitPlace;
		string fontPrefix = (this.fontPrefix == "") ? "ND" : this.fontPrefix;

		// set the sprite based on the above info.
		self.sprite = GetSpriteIndex(fontPrefix .. digitCount .. digitPlace);
		
		// set the frame to the desired digit; since frames A-J (which is 0-9
		// in integer-speak) correspond exactly to the digits 0-9, we're good. Whoop!
		self.frame = DamNum(self).digitValue;
	}

	/*
	 * Spawn damage numbers. Does what it says on the tin.
	 */
	static int spawnDamageNumbers(Actor source = null, Actor target = null, int damage = 0, Name damagetype = 'Default') {

		if(target) {
		
			// if we don't have a source (or it's not a player), try and get one.
			if((!source || !source.player) && playeringame[0]) {
				source = players[0].mo; // player 1 is important! ;)
			}
		
			// if we have a source, angle toward it a bit.
			float ang;
			if(source) {
				ang = target.AngleTo(source, true) + frandom(-20, 20);
			} else {
				ang = frandom(0, 360);
			}

			// pre-calculate velocity/position so we can apply 'em to all spawned nums.
			vector3 nvel = (1.0 * cos(ang), 1.0 * sin(ang), frandom(3.0, 4.0));
			vector3 npos;
		
			// multiply height by 4 if the target's dead to compensate for the reduction.
			float targetHeight = (target.health > 0) ? target.height : (target.height * 4);
			npos = target.pos + (0, 0, targetHeight-16);
			
			// figure out which font to use. This is done here so it doesn't have to
			// be determined for every single digit.

			// [XA] I may turn this into something more interesting than an ugly ol'
			//      switch statement, but laziness prevails at present. Plus I dunno
			//      if we can initialize a const array of structs (yet?)
			
			string fontPrefix;
			float  fontScale;
			float  fontAlpha;
			int    fontRender;

			switch(target.GetCvar('dam_font')) {

				case DAM_FONT_SMALL:
					fontPrefix = 'NS';
					fontScale  = 1.0;
					fontAlpha  = 0.75;
					fontRender = STYLE_Translucent;
					break;

				case DAM_FONT_MODERN:
					fontPrefix = 'ND';
					fontScale  = 1.0;
					fontAlpha  = 1.0;
					fontRender = STYLE_Add;
					break;

				default: // DAM_FONT_CLASSIC
					fontPrefix = 'NC';
					fontScale  = 0.75;
					fontAlpha  = 0.75;
					fontRender = STYLE_Translucent;
			}
		
			// spawn in the damage number digits.
			int dam = min(damage, DAMAGE_CAP);
			int place = 1;
			int length = log10(damage) + 1;
			while(dam > 0) {
				let damnum = DamNum(Spawn("DamNum", npos, ALLOW_REPLACE));
			
				// init the digits... diginit?
				if(damnum) {
					damnum.vel = nvel;
					damnum.angle = ang;
					damnum.A_SetScale(fontScale, fontScale);
					damnum.A_SetRenderStyle(fontAlpha, fontRender);
					damnum.fontPrefix = fontPrefix;
					damnum.digitCount = length;
					damnum.digitPlace = place;
					damnum.digitValue = dam % 10;
					damnum.damageType = damagetype;
				}
			
				// well dam.
				dam /= 10;
				place++;
			}
		}
		
		// return the damage, for easy chaining.
		return damage;
	}
}
