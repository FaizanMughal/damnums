/*
 * DamNums: by Xaser Acheron
 *
 * Events. 'Nuff said.
 */

class DamNumEventHandler : StaticEventHandler
{
	/*
	 * Universal DamNum spawner. If it's a monster, throw some nums!
	 */
	override void WorldThingDamaged(WorldEvent e)
	{
		if (dam_enabled && e.thing && e.Thing.bISMONSTER && e.DamageSource)
		{
			// Just spawn the numbers directly in "shotgun spray" mode;
			// otherwise, let the keeper do its magic.
			if (dam_spray) 
			{
				DamNum.spawnDamageNumbers(e.DamageSource, e.Thing, e.Damage, e.DamageType);
			}
			else
			{
				// Update the keeper's source here, since this is
				// the only event that has access to this info.
				let courier = DamNumCourier(e.Thing.FindInventory("DamNumCourier"));
				if (courier)
				{
					let keeper = courier.keeper;
					if (keeper && keeper.thing)
					{
						keeper.source = e.DamageSource;
					}
				}
			}
		}
	}

	/*
	 * Setup function for actors. Creates a Keeper & Courier pair for monsters
	 * and handles all the relevant setup.
	 */
	override void WorldThingSpawned(WorldEvent e)
	{
		if (e.Thing && e.Thing.bISMONSTER)
		{
			// Create a Keeper for the monster.
			DamNumKeeper keeper = new("DamNumKeeper");
			keeper.thing = e.Thing;

			// Create and gift a Courier to the monster, Give it the inventory so when the monster dies, it can properly
			// release the damage numbers without needing to do anything special
			// in the event the monster disappears immediately afterwards.
			e.Thing.A_SetInventory("DamNumCourier",1);
			let courier = DamNumCourier(e.Thing.FindInventory("DamNumCourier"));
			if (courier)
			{
				courier.keeper = keeper;
			}
		}
	}
}

/*
 * The Courier. This serves as a link between the Keeper and the tracked
 * monster, allowing the latter to communicate with the former (since we can't
 * actually modify the monster definitions to contain an actor pointer to the
 * keeper directly).
 */
class DamNumCourier : Inventory
{
	DamNumKeeper keeper;

	/*
	 * Upon owner death, spawn the last round of numbers. This is necessary to
	 * cover the case where an actor is removed immediately upon death. 
	 *
	 * [MC] The OwnerDied function is called by the monster itself, which is handy.
	 */
	override void OwnerDied()
	{
		if (self.keeper) 
		{
			self.keeper.SpawnAndDestroy();
		}
	}
}

/*
 * The Keeper. Observes an actor, tracks damage changes over the course of a tic,
 * and spawns damage numbers once the tic is complete.
 *
 * [MC] Thinkers are considerably lighter than actors, which makes them ideal for
 *      attaching to actors. They do no special processing -- only what's done in
 *      the tick functions, etc.
 */
class DamNumKeeper : Thinker
{
	Actor thing;
	Actor source;
	uint totalDamage;
	int curHealth;

	/*
	 * Initialize the keeper.
	 *
	 * [MC] For those unaware, when something is created and immediately modified,
	 *      it's all done before the PostBeginPlay function is called. As seen
	 *      in WorldThingSpawned, the modifications (assigning thing, etc)
	 *      are performed within the same code block, allowing this to work.
	 */
	override void PostBeginPlay()
	{
		// Don't spawn a keeper if our tracked thing is gone or already dead.
		// This stops numbers from spawning for PE-spawned Lost Souls that die
		// instantly due to being in a wall. Was amusing, but unintentional. :P
		if (!thing || thing.health < 1)
		{
			return self.Destroy();
		}

		self.curHealth = thing.health;

		Super.PostBeginPlay();
	}

	/*
	 * Track damage and spawn stuff while the actor is alive.
	 */
	override void Tick()
	{
		if (dam_enabled && !dam_spray && self.thing)
		{
			if (self.thing.health < self.curHealth)
			{
				self.SpawnNumbers();
				self.curHealth = self.thing.health;
			}
			// [XA] if I ever add "healing" support, that goes here.
		}
		Super.Tick();
	}

	/*
	 * Do the actual number spawn. There's a bit of calculation and checking
	 * that's common to all Keeper spawns, so it's done here for convenience.
	 */
	void SpawnNumbers()
	{
		if (dam_enabled && !dam_spray && self.thing)
		{
			Vector3 position = self.thing.pos + (0, 0, self.thing.height - 16);
			self.totalDamage = self.curHealth - self.thing.health;
			DamNum.spawnDamageNumbers(self.source, self.thing, self.totalDamage, self.thing.DamageTypeReceived, true, position);
		}
	}

	/*
	 * Does what it says on the tin. Spawns the final round of numbers, then goes "poof".
	 * This seems redundant with Tick(), but there are cases where an actor can
	 * die and be removed before the keeper's Tick() gets called (i.e. D4D's gib deaths),
	 * so we handle actor death as a specific case.
	 */
	void SpawnAndDestroy()
	{
		self.SpawnNumbers();
		self.Destroy();
	}
}
