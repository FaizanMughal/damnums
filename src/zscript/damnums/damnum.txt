/*
 * DamNums: by Xaser Acheron
 */

class DamNum : Actor
{
	string fontPrefix;
	int digitCount;
	int digitPlace;
	uint8 digitValue;
	name damageType;
	
	const FADE_AMT = 0.05;
	const DAMAGE_CAP = 99999;
	
	Default
	{
		RenderStyle 'Add';
		Alpha 1.0;
		Gravity 0.4;
		Scale 0.75;
	
	Translation "DamRed";

		-SOLID;
		+NOBLOCKMAP;
		+NOBLOCKMONST;
		+THRUACTORS;
	}
	States
	{
	Spawn:
		#### # 10 Bright;
		#### # 1 Bright A_FadeOut(FADE_AMT, 1);
		Wait;
	}
	
	/*
	 * DamNum setup function. Sets the correct sprite based
	 * on the digit and the place/number-length. This is necessary
	 * to offset it correctly relative to the viewer.
	 */
	override void PostBeginPlay()
	{
		// Figure out what digit we are.
		DamNum this = DamNum(self);
		int digitCount = (this.digitCount == 0) ? 1 : this.digitCount;
		int digitPlace = (this.digitPlace == 0) ? 1 : this.digitPlace;
		string fontPrefix = (this.fontPrefix == "") ? "ND" : this.fontPrefix;

		// set the sprite based on the above info.
		self.sprite = GetSpriteIndex(fontPrefix .. digitCount .. digitPlace);
		
		// set the frame to the desired digit; since frames A-J (which is 0-9
		// in integer-speak) correspond exactly to the digits 0-9, we're good. Whoop!
		self.frame = DamNum(self).digitValue;
	}

	/*
	 * Spawn damage numbers. Does what it says on the tin.
	 */
	static int spawnDamageNumbers(Actor source = null, Actor target = null, int damage = 0, Name damagetype = 'Default') {
	
		// [TODO] move this to the constants file when it's possible.

		static const String DamTranslations[] =
		{	 "DamBrick"
		,	 "DamTan"
		,	 "DamGray"
		,	 "DamGreen"
		,	 "DamBrown"
		,	 "DamGold"
		,	 "DamRed"
		,	 "DamBlue"
		,	 "DamOrange"
		,	 "DamWhite"
		,	 "DamYellow"
		,	 "DamDefault"
		,	 "DamBlack"
		,	 "DamLightBlue"
		,	 "DamCream"
		,	 "DamOlive"
		,	 "DamDarkGreen"
		,	 "DamDarkRed"
		,	 "DamDarkBrown"
		,	 "DamPurple"
		,	 "DamDarkGray"
		,	 "DamCyan"
		};
		int DamTranslationCount = 22; // [TODO] this better

		if(target) {
		
			// if we don't have a source (or it's not a player), try and get one.
			if((!source || !source.player) && playeringame[0]) {
				source = players[0].mo; // player 1 is important! ;)
			}
		
			// if we have a source, angle toward it a bit.
			float ang;
			if(source) {
				ang = target.AngleTo(source, true) + frandom(-20, 20);
			} else {
				ang = frandom(0, 360);
			}

			// pre-calculate velocity/position so we can apply 'em to all spawned nums.
			vector3 nvel = (1.0 * cos(ang), 1.0 * sin(ang), frandom(3.0, 4.0));
			vector3 npos;
		
			// multiply height by 4 if the target's dead to compensate for the reduction.
			float targetHeight = (target.health > 0) ? target.height : (target.height * 4);
			npos = target.pos + (0, 0, targetHeight-16);
			
			// figure out which font to use. This is done here so it doesn't have to
			// be determined for every single digit.

			// [XA] I may turn this into something more interesting than an ugly ol'
			//      switch statement, but laziness prevails at present. Plus I dunno
			//      if we can initialize a const array of structs (yet?)
			
			string fontPrefix;
			string fontTrans;
			float  fontScale;
			float  fontAlpha;
			int    fontRender;

			switch(target.GetCvar("dam_font")) {

				case DAM_FONT_SMALL:
					fontPrefix = "NS";
					fontTrans  = "DamRed";
					fontScale  = 1.0;
					fontAlpha  = 0.75;
					fontRender = STYLE_Translucent;
					break;

				case DAM_FONT_MODERN:
					fontPrefix = "ND";
					fontTrans  = "DamWhite";
					fontScale  = 1.0;
					fontAlpha  = 1.0;
					fontRender = STYLE_Add;
					break;

				default: // DAM_FONT_CLASSIC
					fontPrefix = "NC";
					fontTrans  = "DamRed";
					fontScale  = 0.75;
					fontAlpha  = 0.75;
					fontRender = STYLE_Translucent;
			}
			
			// check to see if the user is opting for a particular
			// color choice. If so, use it.
			int userColor = target.GetCvar("dam_color");
			if(userColor >= 0 && userColor < DamTranslationCount) {
				fontTrans = DamTranslations[userColor];
			}
		
			// spawn in the damage number digits.
			int dam = min(damage, DAMAGE_CAP);
			int place = 1;
			int length = log10(dam) + 1;
			while(dam > 0) {
				let damnum = DamNum(Spawn("DamNum", npos, ALLOW_REPLACE));
			
				// init the digits... diginit?
				if(damnum) {
					damnum.vel = nvel;
					damnum.angle = ang;
					damnum.A_SetScale(fontScale, fontScale);
					damnum.A_SetRenderStyle(fontAlpha, fontRender);
					damnum.A_SetTranslation(fontTrans);
					damnum.fontPrefix = fontPrefix;
					damnum.digitCount = length;
					damnum.digitPlace = place;
					damnum.digitValue = dam % 10;
					damnum.damageType = damagetype;
				}
			
				// well dam.
				dam /= 10;
				place++;
			}
		}
		
		// return the damage, for easy chaining.
		return damage;
	}

	/*
	 * Accumulate damage. This sneakily uses an inventory item to track the
	 * amount of damage done in a single tic, then spawn a single damage number
	 * once the tic has passed. This allows shotgun-type weapons to spawn a
	 * single damage number rather than an unreadable spray (though the "spray"
	 * behavior is exposed via a cvar in case folks find that amusing).
	 */
	static DamNumAccumulator accumulateDamage(Actor source = null, Actor target = null, int damage = 0, Name damagetype = 'Default') {
		DamNumAccumulator accumulator = null;
		if(target) {
			accumulator = DamNumAccumulator(target.FindInventory('DamNumAccumulator'));
			if(!accumulator) {
				target.A_GiveInventory('DamNumAccumulator', 1);
				accumulator = DamNumAccumulator(target.FindInventory('DamNumAccumulator'));
			}
			accumulator.accumulateDamage(source, damage, damagetype);
		}
		return accumulator;
	}
}
